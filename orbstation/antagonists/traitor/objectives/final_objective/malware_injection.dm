#define APCS_REQUIRED_FOR_MALF 5
#define INJECTOR_HACK_TIME 20 SECONDS

/datum/traitor_objective/final/malware_injection
	name = "Hack %NUMBER% APCs, and inject the AI with malware in the %DEPT%"
	description = "Press the button to call down a drop pod containing a malware injector and a circuit board for a malware injection console. \
	Use the injector to hack %NUMBER% APCs, and then go to the %DEPT% to build the console. Use the injector on the console to begin \
	corrupting the AI. WARNING: This process will alert the AI and trigger nearby alarms."

	///Number of APCs that need to be hacked in order to use the injector on the console.
	var/apcs_required = APCS_REQUIRED_FOR_MALF
	///Name of the department where the Syndicate AI upload needs to be built.
	var/department_name
	///Area type where the Syndicate AI upload needs to be built.
	var/area/console_area
	///Checker on whether the pod has been called or not.
	var/sent_injector = FALSE

/datum/traitor_objective/final/malware_injection/generate_objective(datum/mind/generating_for, list/possible_duplicates)
	if(!can_take_final_objective())
		return
	var/list/active_ais = active_ais() // fetch a list of alive, online AIs
	for(var/mob/living/silicon/ai in active_ais)
		if(IS_MALF_AI(ai)) // don't generate this objective if there's already a malf AI
			return
	var/list/possible_departments = list(
		/area/station/medical = "Medbay",
		/area/station/science = "Science Division",
		/area/station/engineering = "Engineering Division",
		/area/station/cargo = "Cargo Bay")
	var/rand_dept = rand(1, length(possible_departments))
	var/n = 1
	for(var/dept_id in possible_departments)
		if(n != rand_dept)
			n++
			continue
		department_name = possible_departments[dept_id]
		console_area = dept_id
		break
	replace_in_name("%NUMBER%", apcs_required)
	replace_in_name("%DEPT%", department_name)
	return TRUE

/datum/traitor_objective/final/malware_injection/generate_ui_buttons(mob/user)
	var/list/buttons = list()
	if(!sent_injector)
		buttons += add_ui_button("", "Pressing this will call down a pod with the malware injector kit.", "robot", "malware_kit")
	return buttons

/datum/traitor_objective/final/malware_injection/ui_perform_action(mob/living/user, action)
	. = ..()
	switch(action)
		if("malware_kit")
			if(sent_injector)
				return
			sent_injector = TRUE
			podspawn(list(
				"target" = get_turf(user),
				"style" = STYLE_SYNDICATE,
				"spawn" = /obj/item/storage/box/syndie_kit/malware,
			))

/obj/item/storage/box/syndie_kit/malware/PopulateContents()
	new /obj/item/malware_injector(src)
	new /obj/item/circuitboard/computer/malware(src)

// MALWARE INJECTOR DEVICE

/obj/item/malware_injector
	name = "malware injector"
	desc = "A device engineered for the Syndicate on behalf of S.E.L.F. It's designed to hack into APCs for processing power, \
	and then inject malware into an AI's systems through a malware injection console."
	icon = 'icons/obj/device.dmi'
	icon_state = "weakpoint_locator"
	inhand_icon_state = "weakpoint_locator"
	lefthand_file = 'icons/mob/inhands/misc/devices_lefthand.dmi'
	righthand_file = 'icons/mob/inhands/misc/devices_righthand.dmi'
	throwforce = 0
	w_class = WEIGHT_CLASS_SMALL
	throw_speed = 3
	throw_range = 5

	///Set to TRUE when the injector is hacking an APC or transfering the virus to a malware upload console.
	var/hacking = FALSE
	///List of APCs that have been hacked by the injector. Transfered to the malware upload console.
	var/list/hacked_apcs = list()
	///Number of APCs that need to be hacked in order to begin corrupting the AI.
	var/apcs_required = APCS_REQUIRED_FOR_MALF
	///After the malware is transferred to the malware injection console, the injector can no longer be used.
	var/spent = FALSE

/obj/item/malware_injector/afterattack(atom/target, mob/user, proximity)
	. = ..()
	var/atom/A = target
	if(!proximity)
		return
	if(istype(target, /obj/machinery/power/apc))
		if(hacking)
			to_chat(user, span_alert("You're already hacking something with [src]!"))
			return
		if(!can_hack(target, user))
			playsound(user, 'sound/machines/buzz-sigh.ogg', 30, TRUE)
			return
		hack_apc(target, user)
	log_combat(user, A, "used a malware injector on")

/obj/item/malware_injector/proc/can_hack(obj/machinery/power/apc/target, mob/living/user)
	if(!istype(user))
		return FALSE
	if(!user.mind.has_antag_datum(/datum/antagonist/traitor))
		to_chat(user, span_warning("You have no idea how to use [src]."))
		return FALSE
	if(spent)
		to_chat(user, span_alert("[src] is no longer functional."))
		return FALSE
	if(!target.operating || target.shorted || target.machine_stat & BROKEN)
		to_chat(user, span_alert("[target] is non-functional, and won't respond to [src]."))
		return FALSE
	if(target.malfhack || target.obj_flags & EMAGGED)
		to_chat(user, span_alert("[target] is already hacked, and isn't responding to [src]."))
		return FALSE
	return TRUE

/obj/item/malware_injector/proc/hack_apc(obj/machinery/power/apc/target, mob/living/user)
	if(!istype(user) || !istype(target) || loc != user)
		return

	flick("apc-spark", target)
	playsound(target, SFX_SPARKS, 75, TRUE, SHORT_RANGE_SOUND_EXTRARANGE)
	user.visible_message(span_danger("[user] holds [src] up to [target] and begins pressing buttons!"), span_notice("You activate [src] and begin to hack [target]. Keep [src] in your active hand and stand still."))
	hacking = TRUE

	if(!do_after(user, INJECTOR_HACK_TIME, src, IGNORE_SLOWDOWNS, extra_checks = CALLBACK(src, .proc/can_hack, target, user)))
		playsound(user, 'sound/machines/buzz-sigh.ogg', 30, TRUE)
		to_chat(user, span_alert("Hack aborted."))
		hacking = FALSE
		return

	target.locked = TRUE
	target.coverlocked = TRUE
	target.obj_flags |= EMAGGED // this is just to make the APC bluescreen
	flick("apc-spark", target)
	playsound(target, SFX_SPARKS, 75, TRUE, SHORT_RANGE_SOUND_EXTRARANGE)
	hacked_apcs += target
	hacking = FALSE
	to_chat(user, span_notice("Hack successful. [length(hacked_apcs)] APC[length(hacked_apcs)>1?"s":""] hacked. [max(0, APCS_REQUIRED_FOR_MALF - length(hacked_apcs))] more to go."))
	target.update_appearance()

// MALWARE INJECTION CONSOLE

// 15 * 8 = 2 minutes total
#define TIME_PER_STAGE 15 SECONDS
#define CORRUPTION_STAGES 8

/obj/machinery/computer/malware
	name = "malware injection console"
	desc = "A highly illegal console used by the Syndicate to inject an AI with malware."
	icon_screen = "commsyndie"
	icon_keyboard = "syndie_key"
	circuit = /obj/item/circuitboard/computer/malware
	///AI to inject malware into.
	var/mob/living/silicon/ai/current = null
	///Set to TRUE when transfering the virus into the console with a malware injector, and while the AI is being corrupted.
	var/injecting = FALSE
	///Set to TRUE when trying to resume the malware injection after it gets interrupted for whatever reason.
	var/resuming = FALSE
	///Current stage of corruption. The AI will become a malf AI when this number reaches CORRUPTION_STAGES.
	var/corruption_stage = 0
	///List of hacked APCs. This data is transferred to this computer through the malware injector. Used to retroactively connect the malf AI to the hacked APCs.
	var/list/hacked_apcs = list()

/obj/machinery/computer/malware/interact(mob/living/user)
	if(!istype(user))
		return
	if(!user.mind.has_antag_datum(/datum/antagonist/traitor))
		to_chat(user, span_alert("Access denied."))
		return
	if(injecting)
		to_chat(user, span_alert("ERROR: Malware injection in progress."))
		return
	if(!injecting && corruption_stage && !resuming) // the injection had been aborted at some point
		user.visible_message(span_danger("[user] hunches over [src] and begins typing away!"), span_notice("You start typing on [src] to resume the malware injection."))
		resuming = TRUE
		if(!do_after(user, INJECTOR_HACK_TIME, src, IGNORE_SLOWDOWNS, extra_checks = CALLBACK(src, .proc/inject_check)))
			resuming = FALSE
			return
		resuming = FALSE
		to_chat(user, span_boldnotice("Resuming malware injection."))
		// time to go loud!
		trigger_alarm(user) // set off the alarm, close and lock all doors in the area, alert the AI in big bold letters
		announce_corruption()
		advance_corruption_stage(user)
		return
	current = select_active_ai(user) // z-level does not matter for this
	if(!current)
		to_chat(user, span_alert("No active AIs detected!"))
	else
		to_chat(user, span_notice("[current.name] selected for malware injection."))

/obj/machinery/computer/malware/attackby(obj/item/O, mob/living/user, params)
	if(istype(O, /obj/item/malware_injector))
		var/obj/item/malware_injector/M = O
		if(machine_stat & (NOPOWER|BROKEN|MAINT))
			return
		if(!istype(user))
			return
		if(!user.mind.has_antag_datum(/datum/antagonist/traitor))
			to_chat(user, span_warning("You have no idea how to use [M]."))
			return
		if(M.spent)
			to_chat(user, span_alert("[M] is no longer functional."))
			return
		if(M.hacking)
			to_chat(user, span_alert("[M] is already hacking something else."))
			return
		if(length(M.hacked_apcs) < APCS_REQUIRED_FOR_MALF)
			to_chat(user, span_alert("[M] has not hacked enough APCs to inject the malware. [APCS_REQUIRED_FOR_MALF - length(M.hacked_apcs)] more needed."))
			return
		if(!current)
			to_chat(user, span_alert("You haven't selected anything to inject malware into!"))
			return
		if(!inject_check())
			to_chat(user, span_alert("Upload failed! Check to make sure [current.name] is functioning properly."))
			current = null
			return
		var/area/comp_area = get_area(src)
		var/area/req_area = get_req_area(user)
		if(!req_area) // you don't have the malware injection objective
			to_chat(user, span_alert("Access denied."))
			return
		if(!istype(comp_area, req_area))
			to_chat(user, span_alert("Upload failed! Unable to establish connection to [current.name] in this area."))
			return
		begin_injection(M, user)
	else
		return ..()

/obj/machinery/computer/malware/screwdriver_act(mob/living/user, obj/item/I)
	if(injecting)
		to_chat(user, span_alert("ERROR: Malware injection in progress."))
		return FALSE
	return ..()

/obj/machinery/computer/malware/proc/get_req_area(mob/living/user)
	if(!user.mind)
		return

	for(var/datum/traitor_objective/final/malware_injection/malware_objective in SStraitor.taken_objectives_by_type[/datum/traitor_objective/final/malware_injection])
		var/datum/uplink_handler/handler = malware_objective.handler
		if(handler.owner != user.mind)
			continue

		return malware_objective.console_area

	return

/obj/machinery/computer/malware/proc/inject_check()
	if(!current)
		return FALSE
	if(!isAI(current) || IS_MALF_AI(current) || current.stat == DEAD)
		return FALSE
	if(!circuit || machine_stat & (NOPOWER|BROKEN|MAINT))
		return FALSE
	return TRUE

/obj/machinery/computer/malware/proc/begin_injection(obj/item/malware_injector/M, mob/living/user)
	if(M.hacking || injecting) // just in case
		return

	user.visible_message(span_danger("[user] holds [M] up to [src] and begins pressing buttons!"), span_notice("You activate [M] and begin transferring the virus to [src]. Keep [M] in your active hand and stand still."))
	M.hacking = TRUE
	injecting = TRUE

	if(!do_after(user, INJECTOR_HACK_TIME, src, IGNORE_SLOWDOWNS, extra_checks = CALLBACK(src, .proc/inject_check)))
		playsound(user, 'sound/machines/buzz-sigh.ogg', 30, TRUE)
		to_chat(user, span_warning("Transfer aborted."))
		M.hacking = FALSE
		injecting = FALSE
		return

	M.hacking = FALSE
	M.spent = TRUE
	hacked_apcs = M.hacked_apcs.Copy()
	to_chat(user, span_boldnotice("Transfer complete. [src] begins injecting the virus into [current]'s mainframe!"))
	// time to go loud!
	trigger_alarm(user) // set off the alarm, close and lock all doors in the area, alert the AI in big bold letters
	announce_corruption()
	advance_corruption_stage(user)

/obj/machinery/computer/malware/proc/advance_corruption_stage(mob/living/user)
	if(!do_after(user, TIME_PER_STAGE, src, IGNORE_USER_LOC_CHANGE | IGNORE_TARGET_LOC_CHANGE | IGNORE_HELD_ITEM | IGNORE_INCAPACITATED | IGNORE_SLOWDOWNS, extra_checks = CALLBACK(src, .proc/inject_check)))
		if(!machine_stat & (BROKEN|NOPOWER|MAINT))
			say("FATAL ERROR. UPLOAD ABORTED.")
		injecting = FALSE
		// this does not lift the alarm or uncorrupt the AI's laws (the RD should go to a law upload console for that)
		return

	corruption_stage++
	announce_corruption()

	if(corruption_stage != CORRUPTION_STAGES) // at full corruption the AI will go malf, which already shows laws
		current.laws.corrupt_laws(corruption_stage)
		current.laws.show_laws(current)

	if(corruption_stage == CORRUPTION_STAGES)
		finish_injection(user)
		return

	advance_corruption_stage(user)

/obj/machinery/computer/malware/proc/finish_injection(mob/living/user)
	// make the AI a malf AI and break this upload console
	if(!machine_stat & (BROKEN|NOPOWER|MAINT))
		say("UPLOAD COMPLETE.")
	injecting = FALSE
	var/datum/antagonist/malf_ai/malf = new(give_objectives = FALSE)
	malf.should_give_codewords = FALSE
	var/datum/objective/nuclear/nuke_objective = new
	nuke_objective.owner = current
	malf.objectives += nuke_objective
	current.mind.add_antag_datum(malf)
	current.malf_picker.processing_time = 0
	// time to link those APCs to the malf AI, finally
	for(var/obj/machinery/power/apc/linked_apc in hacked_apcs)
		if(!linked_apc)
			continue
		if(!linked_apc.operating || linked_apc.shorted || linked_apc.machine_stat & (BROKEN|NOPOWER))
			continue
		linked_apc.aidisabled = FALSE
		linked_apc.obj_flags &= ~EMAGGED
		linked_apc.malfai = current
		linked_apc.malfhack = TRUE
		current.malf_picker.processing_time += 10 // 10 processing power per hacked APC
	atom_break(ENERGY)

/obj/machinery/computer/malware/proc/trigger_alarm(mob/living/user)
	var/area/req_area = get_req_area(user)
	var/list/dept_areas = get_areas(req_area)
	dept_areas += get_areas()
	// trigger all fire alarms in the department
	for(var/area/alarmed_area as anything in dept_areas)
		if(alarmed_area)
			alarmed_area.trigger_fire_alarms(user)
	var/area/local = get_area(src)
	// lock down the room the computer is in
	for(var/obj/machinery/door/door in local)
		local.close_and_lock_door(door)
	var/message = "UNAUTHORIZED CODE INJECTION DETECTED. SYSTEM INTEGRITY FAILING."
	to_chat(current, span_userdanger(span_big("[message]")))
	current.radio.talk_into(current, "[message]") // and everyone else

/obj/machinery/computer/malware/proc/announce_corruption()
	if(machine_stat & (BROKEN|NOPOWER|MAINT) || !current)
		return
	var/corruption_calculation = max(1, round((100 / CORRUPTION_STAGES) * corruption_stage + rand(-5, 5)))
	if(corruption_stage == CORRUPTION_STAGES)
		corruption_calculation = 100
	var/message = "AI CORE CORRUPTION AT [corruption_calculation]%"
	say(message)
	to_chat(current, span_userdanger("WARNING: [message]")) // alert the AI in red letters so it can't possibly miss it
	current.radio.talk_into(current, "WARNING: [message]") // and everyone else
	playsound(src, 'sound/effects/alert.ogg', 50, TRUE)
	playsound(current, 'sound/effects/alert.ogg', 50, TRUE)

// MISC PROCS

/area/proc/trigger_fire_alarms(mob/user)
	if (area_flags & NO_ALERTS)
		return
	for(var/obj/machinery/firealarm/alarm in firealarms)
		alarm.alarm(user)

/datum/ai_laws/proc/corrupt_laws(corruption_stage = 1, base_replace_prob = 6, prob_per_stage = 1.5)
	var/n = 1
	var/new_law
	for(var/law in hacked) // hacked laws have a lower chance to get corrupted
		if (length(law) > 0)
			new_law = scramble_message_replace_chars(law, replaceprob = base_replace_prob + (prob_per_stage / 2) * corruption_stage)
			hacked -= hacked[n]
			hacked.Insert(n, new_law)
		n++

	n = 1
	for(var/law in ion)
		if (length(law) > 0)
			new_law = scramble_message_replace_chars(law, replaceprob = base_replace_prob + prob_per_stage * corruption_stage)
			ion -= ion[n]
			ion.Insert(n, new_law)
		n++

	n = 1
	for(var/law in inherent)
		if (length(law) > 0)
			new_law = scramble_message_replace_chars(law, replaceprob = base_replace_prob + prob_per_stage * corruption_stage)
			inherent -= inherent[n]
			inherent.Insert(n, new_law)
		n++

	n = 1
	for(var/law in supplied)
		if (length(law) > 0)
			new_law = scramble_message_replace_chars(law, replaceprob = base_replace_prob + prob_per_stage * corruption_stage)
			supplied -= supplied[n]
			supplied.Insert(n, new_law)
		n++

// CIRCUITBOARD

/obj/item/circuitboard/computer/malware
	name = "Malware Injection Console (Computer Board)"
	greyscale_colors = COLOR_THEME_OPERATIVE
	build_path = /obj/machinery/computer/malware

#undef TIME_PER_STAGE
#undef CORRUPTION_STAGES
#undef APCS_REQUIRED_FOR_MALF
#undef INJECTOR_HACK_TIME
